
import argparse  # used to display help messages
import sys       # command line arg parsing
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.sendrecv import sr1, sr
from scapy.volatile import RandShort
import re
import ipaddress
import time
import requests
import json
import fingerprint
import vulnerability_assessment

'''
	python3 network_recon.py to dump help 

	Scans multiple IPs and ports, from files or CLI
	Identifies open/closed TCP, UDP ports
	Dumps output to specified file or CLI

	Attempts to fingerprint ssh, http,
'''

class Configuration:
	startIP = None 
	endIP = None 

	filename = "" 
	outputFileName = "" 

	proto = "TCP" 
	#startPort = 1 
	portList =""
	#endPort = 1024 
	timeoutBetweenScans = 4

	def __init__(self):
		pass

	def __str__(self):
		self.prettyPrint()

	def update(self, start_ip=None, end_ip=None, filename=None, proto=None, portList=None, timeout=None, out=None):
		if(start_ip != None):
			self.startIP=start_ip
		if(end_ip != None):
			self.endIP=end_ip
		if(filename != None):
			self.filename = filename
		if(proto != None):
			self.proto = proto
		if(portList != None):
			self.portList = portList 
		#if(endPort != None):
		#	self.endPort = endPort
		if(timeout != None):
			self.timeoutBetweenScans = timeout 
		if(out != None):
			self.outputFileName = out 

	def prettyPrint(self):
		#print(configuration.iL, configuration.iP, configuration.proto, configuration.ports, configuration.file)
		if(self.filename != None):
			print("Input File ", self.filename)	
		print("Output File ", self.outputFileName)	
		if(self.filename == None):
			print("Starting IP " + self.startIP)	
			print("Ending IP ", self.endIP)
		#print("Starting Port ", self.startPort)	
		#print("Ending Port ", self.endPort)	
		print("Port List ", self.portList)	
		print("Protocol ", self.proto)	
		print("Timeout between scans ", self.timeoutBetweenScans)
		
	def prettyPrint2(self) -> str:
		if(self.filename != None):
			retStr = "Input File " + self.filename + "\r\n"
		retStr += "Output File " + self.outputFileName + "\r\n"
		if(self.filename == None):
			retStr = "Starting IP " + self.startIP + "\r\n"
			retStr += "Ending IP "  + self.endIP + "\r\n"
		#retStr += "Starting Port " + str(self.startPort)	+ "\r\n"
		#retStr += "Ending Port " + str(self.endPort)	+ "\r\n"
		retStr += "Port List " + str(self.portList)	+ "\r\n"
		retStr += "Protocol " + self.proto + "\r\n"	
		retStr += "Timeout between scans " + str(self.timeoutBetweenScans) + "\r\n"
		return retStr

	# hints taken from: https://stackoverflow.com/questions/9539006/python-increment-ipaddress
	# Following examples from python API: https://docs.python.org/3/library/ipaddress.html#module-ipaddress
	# Convert from string to IPAddress object, convert to integer, modify then return back to object
	def incrementIPAddress(self, ipAddress) -> ipaddress:
		try:
			ipAddrObj = ipaddress.ip_address(ipAddress)
		except ValueError as e:
			print(ipAddress + " is an invalid address")
			return None

		intAddr = int(ipAddrObj)	
		intAddr +=1	
		return ipaddress.ip_address(intAddr)

	internalPortList = []
	currentPortIndex = -1 

	def buildPortList(self, portList):
		regExGroup = "[\d\- ]*"
	
		portGroups = re.findall(regExGroup, portList)

		for group in portGroups:
			portRange =""
			if(len(group) == 0):
				continue
			
			#print(group)

			portRange = re.findall("-", group)
			if( len(portRange) != 0):
				print("has range")
				lst = group.split('-')		
				#print(lst[0].lstrip().rstrip())
				#print(lst[1].lstrip().rstrip())
				for p in range(int(lst[0].lstrip().rstrip()), int(lst[1].lstrip().rstrip()) + 1):
					self.internalPortList.append(p)
			else:
				self.internalPortList.append(int(group.lstrip().rstrip()))

		#for l in self.internalPortList:
		#	print(l)

	def getNextPort(self):
		if(self.currentPortIndex == (len(self.internalPortList) - 1)):
			return -1

		self.currentPortIndex +=1
		return self.internalPortList[self.currentPortIndex]
	
	def resetCurrentPort(self):
		self.currentPortIndex = -1



config = Configuration()

def parseInputArgs(inputArgs):
	#print("inputArgs = " + str(inputArgs))
	parser = argparse.ArgumentParser(prog="scanMe", description="My version of nmap", 
								  epilog="Example: python3 NetworkHomework.py -file iptoscan.txt -proto TCP -ports 0-1024,2024 \
									-fout out.txt -timer 2")
	parser.add_argument('-file', type=str,  help='<inputfilename>: Input from list of hosts/networks')
	parser.add_argument('-ip', type=str, help="Single IP or range of IP addresses using start-end")
	parser.add_argument('-proto', type=str,  help='<protocol>: Use TCP or UDP, or ICMP for host discovery')
	parser.add_argument('-ports', type=str,  help='<port(s)>: Can specify a comma-separated list of ports, range of ports using start-end')
	parser.add_argument('-timer', type=int,  help='<seconds>: The amount of time to wait between port scans') 
	parser.add_argument('-fout', type=str,  help='<outputfilename>: Output written here') 
	try:
		args = parser.parse_args(inputArgs) #, namespace=configuration)
	except:
		print("There seems to be a problem with the argments. Try removing spaces between list of ports.")
		exit()

	if (len(inputArgs) == 0):
		parser.print_help()
		exit()
	#print(args.iL, args.ip, args.proto, args.ports, args.file)

	config.update(filename=args.file)
	config.update(out=args.fout)
	config.update(proto=args.proto)
	config.update(timeout=args.timer)

	ip_regex = "(\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})"
	if(args.ip != None):
		res = re.findall(ip_regex, args.ip)
		if(len(res) == 2):
			config.update(start_ip=res[0], end_ip=res[1])
		elif(len(res) == 1):
			config.update(start_ip=res[0], end_ip=res[0])

	'''
	port_regex = "(\d{1,5})"
	try:
		res = re.findall(port_regex, args.ports)
		if(len(res) == 2):
			config.update(startPort=int(res[0]), endPort=int(res[1]))
		elif(len(res) == 1):
			config.update(startPort=int(res[0]), endPort=int(res[0]))
	except:
		pass
	'''
	config.update(portList=args.ports)
	config.buildPortList(args.ports)

	return	
	

def getConfiguration():
	if(config.outputFileName == ""):
		config.prettyPrint()
	else:
		try:
			outputFile = open(config.outputFileName, "a")
		except:
			print("unable to write to output file")
			exit()

		outputFile.write(config.prettyPrint2())
		outputFile.close()
	return

def scanMe():
	ipFile = None
	if(config.filename == ""):
		currentIPAddress = ipaddress.ip_address(config.startIP)
	else:
		try:
			ipFile = open(config.filename, "r")
		except:
			print("Unable to open " + config.filename + " for reading")
			exit()

		currentIPAddress = ipFile.readline().strip()
		config.update(start_ip = currentIPAddress, end_ip=currentIPAddress)
		currentIPAddress = ipaddress.ip_address(currentIPAddress)
	

	while (currentIPAddress <= ipaddress.ip_address(config.endIP)): 
		if(config.outputFileName != ""):
			outputFile = open(config.outputFileName, "a")
			outputFile.write("----- " + format(currentIPAddress) + " -----\r\n")
			outputFile.close()

		print("----- " + format(currentIPAddress) + " -----")
		#currentPort = config.startPort

		#while (currentPort <= config.endPort):
		currentPort = config.getNextPort()
		while ( currentPort != -1):
			portStat = scanIP(format(currentIPAddress), currentPort, config.proto)
			if(config.outputFileName != ""):
				outputFile = open(config.outputFileName, "a")
				outputFile.write(portStat.prettyPrint())
				outputFile.close()
			else:
				print(portStat.prettyPrint() )
			#currentPort += 1
			time.sleep(config.timeoutBetweenScans)
			currentPort = config.getNextPort()
			del(portStat)

		if(ipFile==None):
			currentIPAddress += 1
		else:
			currentIPAddress = ipFile.readline()
			if(currentIPAddress == ""):
				break

			currentIPAddress = currentIPAddress.strip()
			config.update(start_ip = currentIPAddress, end_ip=currentIPAddress)
			currentIPAddress = ipaddress.ip_address(currentIPAddress)

		config.resetCurrentPort()
	
	if(ipFile!=None):
		ipFile.close()

		return


'''
ipAddr - string representing a valid ip addr
portNumber - string representing port number
protocolType - Either TCP or UDP. Validation is assumed
'''
TIMEOUT = 1

class portStatus:
	OPEN = "OPEN" 
	CLOSED = "CLOSED"
	OPEN_FILTERED = "OPEN|FILTERED"

	FOUND = 1
	NOTFOUND = 0
	mTCP = "TCP"
	mUDP = "UDP"
	
	found = NOTFOUND
	portStatus = CLOSED
	portNumber = 0
	proto = mTCP

	fingerprint = ""

	hostExists = False

	def __init__(self, exists=NOTFOUND, status=CLOSED, number=0, proto=mTCP, hostExists=False):
		self.found = exists
		self.portStatus = status
		self.portNumber = number
		self.proto = proto
		self.hostExists = hostExists
	
	def update(self, exists=None, status=None, number=None, proto=None, hostExists=None):
		if(exists != None):
			self.found = exists
		if(status != None):
			self.portStatus = status
		if(number != None):
			self.portNumber = number
		if(proto != None):
			self.proto = proto
		if(hostExists!= None):
			self.hostExists = hostExists 

	def addFingerprint(self, str):
		self.fingerprint = str	

	def prettyPrint(self) -> str:
		if(self.proto == "ICMP"):
			return ("Host Exists? " + str(self.hostExists) + "\r\n")
		else:
			return (str(self.portNumber) + "/" + self.proto + "\t" + self.portStatus + "\r\n" \
		  		+ self.fingerprint)
	

def scanIP(ipAddr, portNumber, protocolType) -> portStatus:
	portResults = portStatus(exists=portStatus.NOTFOUND, proto=protocolType, number=portNumber)
	src_port = RandShort()

	if(protocolType == "ICMP"):
		packet=IP(dst=ipAddr)/ICMP()
	elif(protocolType == "UDP"):
		packet = IP(dst=ipAddr)/UDP(dport=portNumber) #/"udp test data"
		#packet = IP(dst=ipAddr)/ICMP()/"xxxxx" #(dport=portNumber)
	elif(protocolType == "TCP"):
		packet = IP(dst=ipAddr)/TCP(sport=src_port, dport=portNumber, flags="S") #/"test data"

	# send a packet at Layer 3 and wait. If there's a response of ANY kind, we know the host exists
	# NB Seems like scapy function documentation is accessed only w/i scapy application
	# print(sr1.__doc__).
	# Documentation for sending is also in the scapy.sendrecv library

	try:
		rspPacket = sr1(packet, timeout=TIMEOUT) # TODO - this will only work for
	except TimeoutError as e:
		# return unfound
		print("Timeout" f'{TIMEOUT}' " reached")
		if(protocolType == "ICMP"):
			portResults.update(exists=portStatus.NOTFOUND)
		elif(protocolType == "UDP"): # no response means it's there or it's not there
			portResults.update(exists=portStatus.FOUND, status=portStatus.OPEN_FILTERED, number=portNumber)
		else: # TCP
			portResults.update(exists=portStatus.NOTFOUND, number=portNumber)
		return portResults

	#print("got a response so the " f'{ipAddr, portNumber}' " is good")
	#print(rspPacket.summary())
	#if(rspPacket!=None): 
	#	print(rspPacket.show())

	if(protocolType=="ICMP"):
		if(rspPacket==None):
			portResults.update(hostExists=False)
		elif(rspPacket.haslayer("ICMP")):
			portResults.update(hostExists=True)

	elif(protocolType=="UDP"):
		if(rspPacket==None):
			portResults.update(exists=portStatus.FOUND, status=portStatus.OPEN_FILTERED, number=portNumber)
		else:
			# Check if it's closed ?
			#print("Has ICMP? " + str(rspPacket.haslayer(ICMP)))
			if(rspPacket.haslayer(ICMP)):
				portResults.update(exists=portStatus.FOUND, status=portStatus.CLOSED, number=portNumber)
			else:
				print("Unknown response for " + ipAddr + ":" + str(portNumber))
	else:
		if(rspPacket == None):
			portResults.update(exists=portStatus.NOTFOUND)
		else:
			flags = rspPacket.sprintf("%TCP.flags%")

			if(flags == "SA"):
				portResults.update(exists=portStatus.FOUND, status=portStatus.OPEN, number=portNumber)
				packet = IP(dst=ipAddr)/TCP(sport=src_port, dport=portNumber, flags="R")
				#sr1(packet, timeout=TIMEOUT)
				# Since we are manipulating the traffic, the kernel will get the syn_ack and RST the connection
				
				#if(portNumber == 80 or portNumber == 443):

			elif(flags =="RA"):
				portResults.update(exists=portStatus.FOUND, status=portStatus.CLOSED, number=portNumber)

	portResults.addFingerprint(fingerprint(ipAddr, portNumber, protocolType))
	return portResults

#print("Scanning scanme.nmap.org TCP")
#print(scanIP("scanme.nmap.org", 53, "TCP").prettyPrint())
#print("Scanning scanme.nmap.org UDP")
#print(scanIP("scanme.nmap.org", 161, "UDP").prettyPrint())


if __name__ == '__main__':
	parseInputArgs(sys.argv[1:])
	getConfiguration()
	scanMe()
