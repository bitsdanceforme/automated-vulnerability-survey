
import argparse  # used to display help messages
import sys       # command line arg parsing
import socket
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.sendrecv import sr1, sr
from scapy.volatile import RandShort
import re
import ipaddress
import time
import requests
from bs4 import BeautifulSoup
import paramiko
import json

'''
	python3 network_recon.py to dump help 

	Scans multiple IPs and ports, from files or CLI
	Identifies open/closed TCP, UDP ports
	Dumps output to specified file or CLI

	Attempts to fingerprint ssh, http,
'''

class Configuration:
	startIP = None 
	endIP = None 

	filename = "" 
	outputFileName = "" 

	proto = "TCP" 
	#startPort = 1 
	portList =""
	#endPort = 1024 
	timeoutBetweenScans = 4

	def __init__(self):
		pass

	def __str__(self):
		self.prettyPrint()

	def update(self, start_ip=None, end_ip=None, filename=None, proto=None, portList=None, timeout=None, out=None):
		if(start_ip != None):
			self.startIP=start_ip
		if(end_ip != None):
			self.endIP=end_ip
		if(filename != None):
			self.filename = filename
		if(proto != None):
			self.proto = proto
		if(portList != None):
			self.portList = portList 
		#if(endPort != None):
		#	self.endPort = endPort
		if(timeout != None):
			self.timeoutBetweenScans = timeout 
		if(out != None):
			self.outputFileName = out 

	def prettyPrint(self):
		#print(configuration.iL, configuration.iP, configuration.proto, configuration.ports, configuration.file)
		if(self.filename != None):
			print("Input File ", self.filename)	
		print("Output File ", self.outputFileName)	
		if(self.filename == None):
			print("Starting IP " + self.startIP)	
			print("Ending IP ", self.endIP)
		#print("Starting Port ", self.startPort)	
		#print("Ending Port ", self.endPort)	
		print("Port List ", self.portList)	
		print("Protocol ", self.proto)	
		print("Timeout between scans ", self.timeoutBetweenScans)
		
	def prettyPrint2(self) -> str:
		if(self.filename != None):
			retStr = "Input File " + self.filename + "\r\n"
		retStr += "Output File " + self.outputFileName + "\r\n"
		if(self.filename == None):
			retStr = "Starting IP " + self.startIP + "\r\n"
			retStr += "Ending IP "  + self.endIP + "\r\n"
		#retStr += "Starting Port " + str(self.startPort)	+ "\r\n"
		#retStr += "Ending Port " + str(self.endPort)	+ "\r\n"
		retStr += "Port List " + str(self.portList)	+ "\r\n"
		retStr += "Protocol " + self.proto + "\r\n"	
		retStr += "Timeout between scans " + str(self.timeoutBetweenScans) + "\r\n"
		return retStr

	# hints taken from: https://stackoverflow.com/questions/9539006/python-increment-ipaddress
	# Following examples from python API: https://docs.python.org/3/library/ipaddress.html#module-ipaddress
	# Convert from string to IPAddress object, convert to integer, modify then return back to object
	def incrementIPAddress(self, ipAddress) -> ipaddress:
		try:
			ipAddrObj = ipaddress.ip_address(ipAddress)
		except ValueError as e:
			print(ipAddress + " is an invalid address")
			return None

		intAddr = int(ipAddrObj)	
		intAddr +=1	
		return ipaddress.ip_address(intAddr)

	internalPortList = []
	currentPortIndex = -1 

	def buildPortList(self, portList):
		regExGroup = "[\d\- ]*"
	
		portGroups = re.findall(regExGroup, portList)

		for group in portGroups:
			portRange =""
			if(len(group) == 0):
				continue
			
			#print(group)

			portRange = re.findall("-", group)
			if( len(portRange) != 0):
				print("has range")
				lst = group.split('-')		
				#print(lst[0].lstrip().rstrip())
				#print(lst[1].lstrip().rstrip())
				for p in range(int(lst[0].lstrip().rstrip()), int(lst[1].lstrip().rstrip()) + 1):
					self.internalPortList.append(p)
			else:
				self.internalPortList.append(int(group.lstrip().rstrip()))

		#for l in self.internalPortList:
		#	print(l)

	def getNextPort(self):
		if(self.currentPortIndex == (len(self.internalPortList) - 1)):
			return -1

		self.currentPortIndex +=1
		return self.internalPortList[self.currentPortIndex]
	
	def resetCurrentPort(self):
		self.currentPortIndex = -1



config = Configuration()

def parseInputArgs(inputArgs):
	#print("inputArgs = " + str(inputArgs))
	parser = argparse.ArgumentParser(prog="scanMe", description="My version of nmap", 
								  epilog="Example: python3 NetworkHomework.py -file iptoscan.txt -proto TCP -ports 0-1024,2024 \
									-fout out.txt -timer 2")
	parser.add_argument('-file', type=str,  help='<inputfilename>: Input from list of hosts/networks')
	parser.add_argument('-ip', type=str, help="Single IP or range of IP addresses using start-end")
	parser.add_argument('-proto', type=str,  help='<protocol>: Use TCP or UDP, or ICMP for host discovery')
	parser.add_argument('-ports', type=str,  help='<port(s)>: Can specify a comma-separated list of ports, range of ports using start-end')
	parser.add_argument('-timer', type=int,  help='<seconds>: The amount of time to wait between port scans') 
	parser.add_argument('-fout', type=str,  help='<outputfilename>: Output written here') 
	try:
		args = parser.parse_args(inputArgs) #, namespace=configuration)
	except:
		print("There seems to be a problem with the argments. Try removing spaces between list of ports.")
		exit()

	if (len(inputArgs) == 0):
		parser.print_help()
		exit()
	#print(args.iL, args.ip, args.proto, args.ports, args.file)

	config.update(filename=args.file)
	config.update(out=args.fout)
	config.update(proto=args.proto)
	config.update(timeout=args.timer)

	ip_regex = "(\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})"
	if(args.ip != None):
		res = re.findall(ip_regex, args.ip)
		if(len(res) == 2):
			config.update(start_ip=res[0], end_ip=res[1])
		elif(len(res) == 1):
			config.update(start_ip=res[0], end_ip=res[0])

	'''
	port_regex = "(\d{1,5})"
	try:
		res = re.findall(port_regex, args.ports)
		if(len(res) == 2):
			config.update(startPort=int(res[0]), endPort=int(res[1]))
		elif(len(res) == 1):
			config.update(startPort=int(res[0]), endPort=int(res[0]))
	except:
		pass
	'''
	config.update(portList=args.ports)
	config.buildPortList(args.ports)

	return	
	

def getConfiguration():
	if(config.outputFileName == ""):
		config.prettyPrint()
	else:
		try:
			outputFile = open(config.outputFileName, "a")
		except:
			print("unable to write to output file")
			exit()

		outputFile.write(config.prettyPrint2())
		outputFile.close()
	return

def scanMe():
	ipFile = None
	if(config.filename == ""):
		currentIPAddress = ipaddress.ip_address(config.startIP)
	else:
		try:
			ipFile = open(config.filename, "r")
		except:
			print("Unable to open " + config.filename + " for reading")
			exit()

		currentIPAddress = ipFile.readline().strip()
		config.update(start_ip = currentIPAddress, end_ip=currentIPAddress)
		currentIPAddress = ipaddress.ip_address(currentIPAddress)
	

	while (currentIPAddress <= ipaddress.ip_address(config.endIP)): 
		if(config.outputFileName != ""):
			outputFile = open(config.outputFileName, "a")
			outputFile.write("----- " + format(currentIPAddress) + " -----\r\n")
			outputFile.close()

		print("----- " + format(currentIPAddress) + " -----")
		#currentPort = config.startPort

		#while (currentPort <= config.endPort):
		currentPort = config.getNextPort()
		while ( currentPort != -1):
			portStat = scanIP(format(currentIPAddress), currentPort, config.proto)
			if(config.outputFileName != ""):
				outputFile = open(config.outputFileName, "a")
				outputFile.write(portStat.prettyPrint())
				outputFile.close()
			else:
				print(portStat.prettyPrint() )
			#currentPort += 1
			time.sleep(config.timeoutBetweenScans)
			currentPort = config.getNextPort()
			del(portStat)

		if(ipFile==None):
			currentIPAddress += 1
		else:
			currentIPAddress = ipFile.readline()
			if(currentIPAddress == ""):
				break

			currentIPAddress = currentIPAddress.strip()
			config.update(start_ip = currentIPAddress, end_ip=currentIPAddress)
			currentIPAddress = ipaddress.ip_address(currentIPAddress)

		config.resetCurrentPort()
	
	if(ipFile!=None):
		ipFile.close()

		return


'''
ipAddr - string representing a valid ip addr
portNumber - string representing port number
protocolType - Either TCP or UDP. Validation is assumed
'''
TIMEOUT = 1

class portStatus:
	OPEN = "OPEN" 
	CLOSED = "CLOSED"
	OPEN_FILTERED = "OPEN|FILTERED"

	FOUND = 1
	NOTFOUND = 0
	mTCP = "TCP"
	mUDP = "UDP"
	
	found = NOTFOUND
	portStatus = CLOSED
	portNumber = 0
	proto = mTCP

	fingerprint = ""

	hostExists = False

	def __init__(self, exists=NOTFOUND, status=CLOSED, number=0, proto=mTCP, hostExists=False):
		self.found = exists
		self.portStatus = status
		self.portNumber = number
		self.proto = proto
		self.hostExists = hostExists
	
	def update(self, exists=None, status=None, number=None, proto=None, hostExists=None):
		if(exists != None):
			self.found = exists
		if(status != None):
			self.portStatus = status
		if(number != None):
			self.portNumber = number
		if(proto != None):
			self.proto = proto
		if(hostExists!= None):
			self.hostExists = hostExists 

	def addFingerprint(self, str):
		self.fingerprint = str	

	def prettyPrint(self) -> str:
		if(self.proto == "ICMP"):
			return ("Host Exists? " + str(self.hostExists) + "\r\n")
		else:
			return (str(self.portNumber) + "/" + self.proto + "\t" + self.portStatus + "\r\n" \
		  		+ self.fingerprint)
	

'''
Fingerprint any port/service running a webserver (What service and version was discovered). (0.5 pt)
                Inform the user of the type and version server found. (0.5pts)
                If Service is a webserver:
                        Inform the user of the status code returned (for a root request â€“ aka "GET / HTTP/1.1"). (0.5pts)
                        Inform the user of the title of the page found. (0.5pts)
'''

def isWebServer(ip_addr, port_number, protocol) -> str:
	hdrs = {"User-Agent": "curl/7.81.0"} 
	url = "http://" + ip_addr + ":" + str(port_number)
	try:
		header = requests.get(url, params=hdrs, timeout=TIMEOUT)
	except Exception:
		return ""

	headerDictionary = header.headers

	returnString = "\tRoot Request Response: " + str(header.status_code) + "/" + header.reason + "\r\n"
	value = headerDictionary.get("Server")
	returnString += "\tServer: " + value + "\r\n"

	soup = BeautifulSoup(header.content, "html.parser")

	title = soup.find_all('title')
	for t in title:	
		returnString += "\tPage Title: " + t.get_text() 
	returnString += "\r\n"

	#findVulnerabilities(value)
	return returnString

def isSSH(hostname, port):
	res = "" 
	# create a socket connection and grab the banner
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((hostname, port))
	regex = "ssh"

	s.settimeout(TIMEOUT)
	try:
		resp = s.recv(1024)
	except:
		return res

	version = re.findall(regex, str(resp, "utf-8").lower())
	if(len(version) > 0): # != None):
		res = str(f'SSH Service Found {str(resp, "utf-8")}')
	s.close()
	#findVulnerabilities(str(resp, "utf-8").strip("\r\n"))
	return res 

def isTelnet(hostname, port):
	res = "" 
	# create a socket connection and grab the banner
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((hostname, port))
	regex = "telnet"

	s.settimeout(TIMEOUT)
	try:
		resp = s.recv(1024)
	except:
		return res

	if(len(re.findall(regex,str(resp, "utf-8").lower())) > 0): #!= None):
		res = str(f'Telnet Service Found {resp}\r\n')
	s.close()
	return res

def isSMTP(hostname, port):
	res = "" 
	# create a socket connection and grab the banner
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((hostname, port))
	regex = "smtp"

	s.settimeout(TIMEOUT)
	try:
		resp = s.recv(1024)
	except:
		return res

	if(len(re.findall(regex,str(resp, "utf-8").lower())) > 0): # != None):
		res = str(f'SMTP Service Found {resp}\r\n')
	s.close()
	return res

def isFTP(hostname, port):
	res = "" 
	# create a socket connection and grab the banner
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((hostname, port))
	regex = "ftp"

	s.settimeout(TIMEOUT)
	try:
		resp = s.recv(1024)
	except:
		return res

	if(len(re.findall(regex,str(resp, "utf-8").lower())) > 0): # != None):
		res = str(f'FTP Service Found {resp}\r\n')
	s.close()

	#findVulnerabilities()
	return res

def fingerprint(ip_addr, port_number, protocol):
	''' ripping off the nmap technique - connect and then wait to get some banners '''
	''' I need an actual connection here, not letting the kernel RST things on us.... 
		But, the data does seem to get to us before the kernel shuts down, so maybe we
		wait a bit longer in the receive side?
	'''
	print = ""

	print = isWebServer(ip_addr, port_number, protocol)
	if(print == ""):
		print = isSSH(ip_addr, port_number)
	if(print == ""):
		print = isTelnet(ip_addr, port_number)
	if(print == ""):
		print = isSMTP(ip_addr, port_number)
	if(print == ""):
		print = isFTP(ip_addr, port_number)
	
	return print 

#print(fingerprint("45.33.32.156", 80, "TCP"))

# input string consisting of service and version
# output list of CVEs
def findVulnerabilities(serviceStr) -> dict:
	cves = None 
	url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
	formdata = {"keywordSearch": serviceStr} # Make sure this is a dictionary!
	resp = requests.get(url, params=formdata)

	if (resp.ok):
		cves = json.loads(resp.content)  # Pull the content into json structure
		print(type(cves))
		print("Number of CVEs:", cves["totalResults"])
	else:
		print("Unable to connect to CVE database")
	
	return cves 


def scanIP(ipAddr, portNumber, protocolType) -> portStatus:
	portResults = portStatus(exists=portStatus.NOTFOUND, proto=protocolType, number=portNumber)
	src_port = RandShort()

	if(protocolType == "ICMP"):
		packet=IP(dst=ipAddr)/ICMP()
	elif(protocolType == "UDP"):
		packet = IP(dst=ipAddr)/UDP(dport=portNumber) #/"udp test data"
		#packet = IP(dst=ipAddr)/ICMP()/"xxxxx" #(dport=portNumber)
	elif(protocolType == "TCP"):
		packet = IP(dst=ipAddr)/TCP(sport=src_port, dport=portNumber, flags="S") #/"test data"

	# send a packet at Layer 3 and wait. If there's a response of ANY kind, we know the host exists
	# NB Seems like scapy function documentation is accessed only w/i scapy application
	# print(sr1.__doc__).
	# Documentation for sending is also in the scapy.sendrecv library

	try:
		rspPacket = sr1(packet, timeout=TIMEOUT) # TODO - this will only work for
	except TimeoutError as e:
		# return unfound
		print("Timeout" f'{TIMEOUT}' " reached")
		if(protocolType == "ICMP"):
			portResults.update(exists=portStatus.NOTFOUND)
		elif(protocolType == "UDP"): # no response means it's there or it's not there
			portResults.update(exists=portStatus.FOUND, status=portStatus.OPEN_FILTERED, number=portNumber)
		else: # TCP
			portResults.update(exists=portStatus.NOTFOUND, number=portNumber)
		return portResults

	#print("got a response so the " f'{ipAddr, portNumber}' " is good")
	#print(rspPacket.summary())
	#if(rspPacket!=None): 
	#	print(rspPacket.show())

	if(protocolType=="ICMP"):
		if(rspPacket==None):
			portResults.update(hostExists=False)
		elif(rspPacket.haslayer("ICMP")):
			portResults.update(hostExists=True)

	elif(protocolType=="UDP"):
		if(rspPacket==None):
			portResults.update(exists=portStatus.FOUND, status=portStatus.OPEN_FILTERED, number=portNumber)
		else:
			# Check if it's closed ?
			#print("Has ICMP? " + str(rspPacket.haslayer(ICMP)))
			if(rspPacket.haslayer(ICMP)):
				portResults.update(exists=portStatus.FOUND, status=portStatus.CLOSED, number=portNumber)
			else:
				print("Unknown response for " + ipAddr + ":" + str(portNumber))
	else:
		if(rspPacket == None):
			portResults.update(exists=portStatus.NOTFOUND)
		else:
			flags = rspPacket.sprintf("%TCP.flags%")

			if(flags == "SA"):
				portResults.update(exists=portStatus.FOUND, status=portStatus.OPEN, number=portNumber)
				packet = IP(dst=ipAddr)/TCP(sport=src_port, dport=portNumber, flags="R")
				#sr1(packet, timeout=TIMEOUT)
				# Since we are manipulating the traffic, the kernel will get the syn_ack and RST the connection
				
				#if(portNumber == 80 or portNumber == 443):

			elif(flags =="RA"):
				portResults.update(exists=portStatus.FOUND, status=portStatus.CLOSED, number=portNumber)

	portResults.addFingerprint(fingerprint(ipAddr, portNumber, protocolType))
	return portResults

#print("Scanning scanme.nmap.org TCP")
#print(scanIP("scanme.nmap.org", 53, "TCP").prettyPrint())
#print("Scanning scanme.nmap.org UDP")
#print(scanIP("scanme.nmap.org", 161, "UDP").prettyPrint())


if __name__ == '__main__':
	parseInputArgs(sys.argv[1:])
	getConfiguration()
	scanMe()
